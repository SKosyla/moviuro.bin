#!/bin/sh

#ffmpeg -i 3f8WK1r.gif -filter_complex color=c=white:size=3640x1920 [base];
#[0:v] setpts=PTS-STARTPTS [upperleft];
#[0:v] setpts=PTS-STARTPTS [second];
#[base][upperleft] overlay=shortest=1 [tmp1];
#[tmp1][second] overlay=shortest=1:x=1000:y=toto -c:v libx264 out.mkv

[ -r "$1" ] || exit 99

__getnum() {
  grep -Eo '[0-9]+'
}

__bg () {
  # Select bg color:
  # convert(1) to extract the single top-left pixel and extract its color
  # throughout the .gif; then grep for its only values that are NOT transparent
  # and then take the first one
  _solid_color="$(convert "$1" -crop 1x1+0+0 -depth 8 txt: | grep -Eo \
    '#[A-F0-9]{6}(FF|)' | sort -u | head -n 1)"

  # Now $_solid_color contains either #RRGGBB or #RRGGBBAA and we need to
  # discard the 'AA' part (where AA = FF anyway, because we used grep earlier),
  # hence the '%%FF'
  _solid_color="${_solid_color%%FF}"

  printf '%s\n' "${_solid_color}"
}

# Step 1: get file resolution & BG color
# https://superuser.com/questions/841235/how-do-i-use-ffmpeg-to-get-the-video-resolution
ffprobe -v error -select_streams v:0 -show_entries stream=width,height \
 -of csv=s=x:p=0 "$1" |
  while IFS='x' read -r _x_vid _y_vid; do

# Step 2: get the screen info
_i=0
xrandr -q | grep ' connected ' | grep -Eo '[0-9]+x[0-9]+\+[0-9]+\+[0-9]+' | {
 while IFS='+x' read -r _x _y _x_offset _y_offset; do
   # X coordinates
   _new_X="$(( _x + _x_offset))"
   ((_new_X > _X)) && _X="$_new_X"
   _v_x="$(( (_x - _x_vid)/2 + _x_offset ))"
   # Y coordinates
   _new_Y="$(( _y + _y_offset))"
   ((_new_Y > _Y)) && _Y="$_new_Y"
   _v_y="$(( (_y - _y_vid)/2 + _y_offset ))"
   # We continue building the filter
   _filter="$_filter [0:v] setpts=PTS-STARTPTS [screen$_i];"
   _filter_end="$_filter_end [tmp$((_i - 1))][screen${_i}] overlay=shortest=1:x=${_v_x}:y=${_v_y} [tmp$_i];"
   : $((_i+=1))
 done

_filter="color=c=$(__bg "$1"):size=${_X}x${_Y} [tmp-1]; $_filter $_filter_end"
_filter="${_filter%\[*}"
ffmpeg -i "$1" -filter_complex "$_filter" -c:v libx264 out.mkv

}
done

